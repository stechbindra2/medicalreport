/**
 * Service for exporting summaries in various file formats
 */
const fs = require('fs');
const path = require('path');
const PDFDocument = require('pdfkit');
const ExcelJS = require('exceljs');
const docx = require('docx');
const { Document, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, AlignmentType, Header, Footer } = docx;
const { Packer } = docx;
const handlebars = require('handlebars');

// Template directory
const TEMPLATES_DIR = path.join(__dirname, '../templates');

// Ensure templates directory exists
if (!fs.existsSync(TEMPLATES_DIR)) {
  fs.mkdirSync(TEMPLATES_DIR, { recursive: true });
}

/**
 * Format date in a readable way
 * @returns {string} Formatted date
 */
function getFormattedDate() {
  const date = new Date();
  return date.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
}

/**
 * Export summary as PDF
 * @param {Object} data - Report data with summary and masked content
 * @param {string} templateName - Template to use (default, professional, clinical, etc)
 * @returns {Promise<Buffer>} - PDF file buffer
 */
async function exportToPDF(data, templateName = 'default') {
  return new Promise((resolve, reject) => {
    try {
      // Create PDF document
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4',
      });
      
      // Set up buffer to store PDF
      const buffers = [];
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfData = Buffer.concat(buffers);
        resolve(pdfData);
      });

      // Add header with text-based logo instead of image
      doc.fillColor('#1976d2')
         .fontSize(28)
         .text('MediSummarize', 50, 50)
         .fillColor('#666666')
         .fontSize(12)
         .text('AI-Powered Medical Report Summary', 50);

      // Add date and report type
      doc.moveDown(2)
         .fillColor('#333333')
         .fontSize(14)
         .text(`Report Date: ${getFormattedDate()}`, { align: 'right' });

      // Title
      doc.moveDown(1)
         .fillColor('#1976d2')
         .fontSize(18)
         .text('Medical Report Summary', { align: 'center' });

      // Summary content
      doc.moveDown(1)
         .fillColor('#333333')
         .fontSize(12)
         .text('AI-Generated Summary:', { underline: true })
         .moveDown(0.5);

      // Split the summary into paragraphs for better formatting
      const paragraphs = data.summary.split('\n').filter(p => p.trim() !== '');
      paragraphs.forEach(paragraph => {
        doc.fontSize(11)
           .text(paragraph, {
             align: 'justify',
             lineGap: 5
           })
           .moveDown(0.5);
      });
      
      // Add a section divider
      doc.moveDown(1)
         .strokeColor('#1976d2')
         .lineWidth(1)
         .moveTo(50, doc.y)
         .lineTo(550, doc.y)
         .stroke()
         .moveDown(1);

      // Masked content section
      doc.fillColor('#333333')
         .fontSize(12)
         .text('Reference: Masked Medical Report', { underline: true })
         .moveDown(0.5);

      // Add masked report with monospaced font
      doc.font('Courier')
         .fontSize(9)
         .text(data.maskedReport, {
           align: 'left',
           lineGap: 2
         });

      // Footer
      const footerPosition = doc.page.height - 50;
      doc.fontSize(10)
         .fillColor('#666666')
         .text(
           'This report was automatically generated by MediSummarize. ' +
           'All sensitive information has been masked for privacy.',
           50, footerPosition, { align: 'center', width: 500 }
         );

      // Add page numbers - Fixed to handle page numbering correctly
      // First get current page and then add page numbers
      const currentPage = doc.page;
      
      // Add page number to the current page
      doc.text(
        `Page 1 of 1`, // Simplified since most reports will be single page
        50, footerPosition - 20,
        { align: 'right', width: 500 }
      );
      
      // If there are multiple pages (unlikely but possible), we can implement 
      // a more complex solution using doc.on('pageAdded') event

      // Finalize the PDF
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Export summary as DOCX
 * @param {Object} data - Report data with summary and masked content
 * @param {string} templateName - Template to use
 * @returns {Promise<Buffer>} - DOCX file buffer
 */
async function exportToDOCX(data, templateName = 'default') {
  try {
    // Create sections for the document
    const sections = [];

    // Header section
    const title = new Paragraph({
      text: "Medical Report Summary",
      heading: HeadingLevel.HEADING_1,
      alignment: AlignmentType.CENTER,
      thematicBreak: true,
      spacing: {
        after: 200,
      },
    });

    // Date section
    const dateText = new Paragraph({
      text: `Report Date: ${getFormattedDate()}`,
      alignment: AlignmentType.RIGHT,
      spacing: {
        before: 200,
        after: 200,
      },
    });

    // Summary section title
    const summaryTitle = new Paragraph({
      children: [
        new TextRun({
          text: "AI-Generated Summary",
          bold: true,
          size: 28,
          color: "1976d2",
        }),
      ],
      spacing: {
        before: 200,
        after: 200,
      },
    });

    // Summary content - split into paragraphs
    const summaryParagraphs = data.summary.split('\n')
      .filter(p => p.trim() !== '')
      .map(text => {
        return new Paragraph({
          text: text,
          spacing: {
            after: 120,
          },
        });
      });

    // Masked report section title
    const maskedTitle = new Paragraph({
      children: [
        new TextRun({
          text: "Reference: Masked Medical Report",
          bold: true,
          size: 28,
          color: "1976d2",
        }),
      ],
      spacing: {
        before: 400,
        after: 200,
      },
    });

    // Masked content
    const maskedContent = new Paragraph({
      text: data.maskedReport,
      spacing: {
        before: 200,
      },
      style: "monospaced",
    });

    // Create the document
    const doc = new Document({
      styles: {
        paragraphStyles: [
          {
            id: "monospaced",
            name: "Monospaced",
            run: {
              font: "Courier New",
              size: 20,
            },
          },
        ],
      },
      sections: [
        {
          properties: {},
          headers: {
            default: new Header({
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: "MediSummarize - AI-Powered Medical Report Summary",
                      bold: true,
                      color: "1976d2",
                    }),
                  ],
                  alignment: AlignmentType.RIGHT,
                }),
              ],
            }),
          },
          footers: {
            default: new Footer({
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: "This report was automatically generated by MediSummarize. All sensitive information has been masked for privacy.",
                      size: 18,
                    }),
                  ],
                  alignment: AlignmentType.CENTER,
                }),
              ],
            }),
          },
          children: [
            title,
            dateText,
            summaryTitle,
            ...summaryParagraphs,
            maskedTitle,
            maskedContent,
          ],
        },
      ],
    });

    // Generate the DOCX file
    const buffer = await Packer.toBuffer(doc);
    return buffer;
  } catch (error) {
    throw new Error(`Failed to generate DOCX: ${error.message}`);
  }
}

/**
 * Export summary as XLSX
 * @param {Object} data - Report data with summary and masked content
 * @param {string} templateName - Template to use
 * @returns {Promise<Buffer>} - XLSX file buffer
 */
async function exportToXLSX(data, templateName = 'default') {
  try {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'MediSummarize';
    workbook.created = new Date();

    // Add summary worksheet
    const summarySheet = workbook.addWorksheet('Summary');
    
    // Configure columns
    summarySheet.columns = [
      { header: 'Report Section', key: 'section', width: 20 },
      { header: 'Content', key: 'content', width: 80 }
    ];
    
    // Add title and metadata
    summarySheet.addRow(['Report Title', 'Medical Report Summary']);
    summarySheet.addRow(['Generated Date', getFormattedDate()]);
    summarySheet.addRow(['']);
    summarySheet.addRow(['AI SUMMARY', '']);
    
    // Format the header rows
    summarySheet.getRow(1).font = { bold: true, color: { argb: '1976d2' } };
    summarySheet.getRow(4).font = { bold: true };
    
    // Add the summary - split by paragraphs for better organization
    const summaryParagraphs = data.summary.split('\n').filter(p => p.trim() !== '');
    
    summaryParagraphs.forEach((paragraph) => {
      summarySheet.addRow(['', paragraph]);
    });
    
    summarySheet.addRow(['']);
    summarySheet.addRow(['MASKED REPORT', '']);
    summarySheet.getRow(summarySheet.rowCount).font = { bold: true };
    
    // Add masked report content
    const maskedLines = data.maskedReport.split('\n');
    maskedLines.forEach((line) => {
      summarySheet.addRow(['', line]);
    });
    
    // Apply some styling
    summarySheet.eachRow((row, rowNumber) => {
      row.alignment = { wrapText: true, vertical: 'middle' };
    });
    
    // Create buffer
    const buffer = await workbook.xlsx.writeBuffer();
    return buffer;
  } catch (error) {
    throw new Error(`Failed to generate XLSX: ${error.message}`);
  }
}

/**
 * Export summary as CSV
 * @param {Object} data - Report data with summary and masked content
 * @param {string} templateName - Template to use
 * @returns {Promise<string>} - CSV content
 */
async function exportToCSV(data, templateName = 'default') {
  try {
    // Create CSV content with sections
    let csvContent = 'Section,Content\n';
    csvContent += `Report Title,"Medical Report Summary"\n`;
    csvContent += `Generated Date,"${getFormattedDate()}"\n`;
    csvContent += `\n`;
    csvContent += `AI SUMMARY,""\n`;
    
    // Add summary paragraphs
    const summaryParagraphs = data.summary.split('\n').filter(p => p.trim() !== '');
    summaryParagraphs.forEach((paragraph) => {
      // Escape quotes in the paragraph
      const escapedParagraph = paragraph.replace(/"/g, '""');
      csvContent += `,"${escapedParagraph}"\n`;
    });
    
    csvContent += `\n`;
    csvContent += `MASKED REPORT,""\n`;
    
    // Add masked report content
    const maskedLines = data.maskedReport.split('\n');
    maskedLines.forEach((line) => {
      // Escape quotes in the line
      const escapedLine = line.replace(/"/g, '""');
      csvContent += `,"${escapedLine}"\n`;
    });
    
    return csvContent;
  } catch (error) {
    throw new Error(`Failed to generate CSV: ${error.message}`);
  }
}

/**
 * Export summary as HTML
 * @param {Object} data - Report data with summary and masked content
 * @param {string} templateName - Template to use
 * @returns {Promise<string>} - HTML content
 */
async function exportToHTML(data, templateName = 'default') {
  try {
    // Basic HTML template
    const htmlTemplate = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Medical Report Summary</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          max-width: 800px;
          margin: 0 auto;
          padding: 20px;
        }
        .header {
          text-align: center;
          margin-bottom: 30px;
          padding-bottom: 10px;
          border-bottom: 1px solid #1976d2;
        }
        .logo {
          color: #1976d2;
          font-size: 24px;
          font-weight: bold;
        }
        .subtitle {
          color: #666;
          font-size: 16px;
        }
        .date {
          text-align: right;
          margin-bottom: 20px;
        }
        h1 {
          color: #1976d2;
          text-align: center;
        }
        .summary-title, .masked-title {
          color: #1976d2;
          font-weight: bold;
          margin-top: 30px;
          border-bottom: 1px solid #eee;
          padding-bottom: 5px;
        }
        .summary-content {
          margin-bottom: 30px;
        }
        .masked-content {
          font-family: monospace;
          white-space: pre-wrap;
          background-color: #f9f9f9;
          padding: 15px;
          border: 1px solid #eee;
          border-radius: 4px;
        }
        .footer {
          margin-top: 40px;
          padding-top: 10px;
          border-top: 1px solid #eee;
          text-align: center;
          font-size: 12px;
          color: #666;
        }
      </style>
    </head>
    <body>
      <div class="header">
        <div class="logo">MediSummarize</div>
        <div class="subtitle">AI-Powered Medical Report Summary</div>
      </div>
      
      <div class="date">Report Date: ${getFormattedDate()}</div>
      
      <h1>Medical Report Summary</h1>
      
      <div class="summary-section">
        <h2 class="summary-title">AI-Generated Summary</h2>
        <div class="summary-content">
          ${data.summary.split('\n').map(p => `<p>${p}</p>`).join('')}
        </div>
      </div>
      
      <div class="masked-section">
        <h2 class="masked-title">Reference: Masked Medical Report</h2>
        <div class="masked-content">${data.maskedReport}</div>
      </div>
      
      <div class="footer">
        This report was automatically generated by MediSummarize. 
        All sensitive information has been masked for privacy.
      </div>
    </body>
    </html>
    `;
    
    return htmlTemplate;
  } catch (error) {
    throw new Error(`Failed to generate HTML: ${error.message}`);
  }
}

module.exports = {
  exportToPDF,
  exportToDOCX,
  exportToXLSX,
  exportToCSV,
  exportToHTML
};
